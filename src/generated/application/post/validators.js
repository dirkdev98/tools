// Generated by @compas/code-gen

/**
 * @template T, E
 * @typedef {{ value: T, error?: never}|{ value?: never, error: E }} Either
 */

/**
 * @typedef {Record<string, any|undefined>} ValidatorErrorMap
 */

/**
 * @param {import("../common/types").PostUpdateParams|any} value
 * @returns {Either<import("../common/types").PostUpdateParams, ValidatorErrorMap>}
 */
export function validatePostUpdateParams(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["postId"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["postId"] === null || value["postId"] === undefined) {
        errorMap[`$.postId`] = {
          key: "validator.undefined",
        };
      } else {
        if (
          typeof value["postId"] !== "string" ||
          (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
            value["postId"],
          ) &&
            !/^[a-f0-9]{32}$/gi.test(value["postId"]))
        ) {
          errorMap[`$.postId`] = {
            key: "validator.pattern",
            patternExplanation: "UUID",
          };
        } else if (value["postId"].length === 32) {
          result["postId"] =
            value["postId"].slice(0, 8) +
            "-" +
            value["postId"].slice(8, 12) +
            "-" +
            value["postId"].slice(12, 16) +
            "-" +
            value["postId"].slice(16, 20) +
            "-" +
            value["postId"].slice(20);
        } else {
          result["postId"] = value["postId"];
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostUpdateBody|any} value
 * @returns {Either<import("../common/types").PostUpdateBody, ValidatorErrorMap>}
 */
export function validatePostUpdateBody(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["text"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["text"] === null || value["text"] === undefined) {
        errorMap[`$.text`] = {
          key: "validator.undefined",
        };
      } else {
        /** @type {string} */
        let convertedString1 = value["text"];
        if (typeof convertedString1 !== "string") {
          errorMap[`$.text`] = {
            key: "validator.string",
          };
        } else {
          if (convertedString1.length < 10) {
            errorMap[`$.text`] = {
              key: "validator.length",
              minLength: 10,
            };
          } else {
            result["text"] = convertedString1;
          }
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostUpdateResponse|any} value
 * @returns {Either<import("../common/types").PostUpdateResponseRouterValidated, ValidatorErrorMap>}
 */
export function validatePostUpdateResponseRouterValidated(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["success"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["success"] === null || value["success"] === undefined) {
        errorMap[`$.success`] = {
          key: "validator.undefined",
        };
      } else {
        if (
          value["success"] === true ||
          value["success"] === "true" ||
          value["success"] === 1
        ) {
          result["success"] = true;
        } else {
          errorMap[`$.success`] = {
            key: "validator.oneOf",
            allowedValues: [true],
            foundValue: value["success"],
          };
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostListQueryValidatorInput|any} value
 * @returns {Either<import("../common/types").PostListQuery, ValidatorErrorMap>}
 */
export function validatePostListQuery(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["offset", "limit"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["offset"] === null || value["offset"] === undefined) {
        result["offset"] = 0;
      } else {
        let convertedNumber1 = value["offset"];
        if (
          typeof convertedNumber1 !== "number" &&
          typeof convertedNumber1 === "string"
        ) {
          convertedNumber1 = Number(convertedNumber1);
        }
        if (
          typeof convertedNumber1 !== "number" ||
          isNaN(convertedNumber1) ||
          !isFinite(convertedNumber1) ||
          !Number.isInteger(convertedNumber1)
        ) {
          errorMap[`$.offset`] = {
            key: "validator.number",
            subType: "int",
          };
        } else if (convertedNumber1 < -2147483647) {
          errorMap[`$.offset`] = {
            key: "validator.range",
            minValue: -2147483647,
          };
        } else if (convertedNumber1 > 2147483647) {
          errorMap[`$.offset`] = {
            key: "validator.range",
            maxValue: 2147483647,
          };
        } else {
          result["offset"] = convertedNumber1;
        }
      }
      if (value["limit"] === null || value["limit"] === undefined) {
        result["limit"] = 50;
      } else {
        let convertedNumber2 = value["limit"];
        if (
          typeof convertedNumber2 !== "number" &&
          typeof convertedNumber2 === "string"
        ) {
          convertedNumber2 = Number(convertedNumber2);
        }
        if (
          typeof convertedNumber2 !== "number" ||
          isNaN(convertedNumber2) ||
          !isFinite(convertedNumber2) ||
          !Number.isInteger(convertedNumber2)
        ) {
          errorMap[`$.limit`] = {
            key: "validator.number",
            subType: "int",
          };
        } else if (convertedNumber2 > 5000) {
          errorMap[`$.limit`] = {
            key: "validator.range",
            maxValue: 5000,
          };
        } else {
          result["limit"] = convertedNumber2;
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostListBodyValidatorInput|any} value
 * @returns {Either<import("../common/types").PostListBody, ValidatorErrorMap>}
 */
export function validatePostListBody(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["where", "orderBy", "orderBySpec"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["where"] === null || value["where"] === undefined) {
        result["where"] = undefined;
      } else {
        if (
          typeof value["where"] !== "object" ||
          Array.isArray(value["where"])
        ) {
          errorMap[`$.where`] = {
            key: "validator.object",
            value: value["where"],
            foundType: typeof value["where"],
          };
        } else {
          /** @type {Set<string>} */
          const knownKeys1 = new Set([
            "id",
            "idNotEqual",
            "idIn",
            "idNotIn",
            "title",
            "titleNotEqual",
            "titleIn",
            "titleNotIn",
            "titleLike",
            "titleILike",
            "titleNotLike",
            "createdAt",
            "createdAtNotEqual",
            "createdAtIn",
            "createdAtNotIn",
            "createdAtGreaterThan",
            "createdAtLowerThan",
            "updatedAt",
            "updatedAtNotEqual",
            "updatedAtIn",
            "updatedAtNotIn",
            "updatedAtGreaterThan",
            "updatedAtLowerThan",
          ]);
          for (const key of Object.keys(value["where"])) {
            if (
              !knownKeys1.has(key) &&
              value["where"][key] !== null &&
              value["where"][key] !== undefined
            ) {
              const expectedKeys = [...knownKeys1];
              const foundKeys = Object.keys(value["where"]);
              const unknownKeys = foundKeys.filter((it) => !knownKeys1.has(it));
              errorMap[`$.where`] = {
                key: "validator.keys",
                unknownKeys,
                expectedKeys,
                foundKeys,
              };
              break;
            }
          }
          result["where"] = Object.create(null);

          if (
            value["where"]["id"] === null ||
            value["where"]["id"] === undefined
          ) {
            result["where"]["id"] = undefined;
          } else {
            if (
              typeof value["where"]["id"] !== "string" ||
              (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
                value["where"]["id"],
              ) &&
                !/^[a-f0-9]{32}$/gi.test(value["where"]["id"]))
            ) {
              errorMap[`$.where.id`] = {
                key: "validator.pattern",
                patternExplanation: "UUID",
              };
            } else if (value["where"]["id"].length === 32) {
              result["where"]["id"] =
                value["where"]["id"].slice(0, 8) +
                "-" +
                value["where"]["id"].slice(8, 12) +
                "-" +
                value["where"]["id"].slice(12, 16) +
                "-" +
                value["where"]["id"].slice(16, 20) +
                "-" +
                value["where"]["id"].slice(20);
            } else {
              result["where"]["id"] = value["where"]["id"];
            }
          }
          if (
            value["where"]["idNotEqual"] === null ||
            value["where"]["idNotEqual"] === undefined
          ) {
            result["where"]["idNotEqual"] = undefined;
          } else {
            if (
              typeof value["where"]["idNotEqual"] !== "string" ||
              (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
                value["where"]["idNotEqual"],
              ) &&
                !/^[a-f0-9]{32}$/gi.test(value["where"]["idNotEqual"]))
            ) {
              errorMap[`$.where.idNotEqual`] = {
                key: "validator.pattern",
                patternExplanation: "UUID",
              };
            } else if (value["where"]["idNotEqual"].length === 32) {
              result["where"]["idNotEqual"] =
                value["where"]["idNotEqual"].slice(0, 8) +
                "-" +
                value["where"]["idNotEqual"].slice(8, 12) +
                "-" +
                value["where"]["idNotEqual"].slice(12, 16) +
                "-" +
                value["where"]["idNotEqual"].slice(16, 20) +
                "-" +
                value["where"]["idNotEqual"].slice(20);
            } else {
              result["where"]["idNotEqual"] = value["where"]["idNotEqual"];
            }
          }
          if (
            value["where"]["idIn"] === null ||
            value["where"]["idIn"] === undefined
          ) {
            errorMap[`$.where.idIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap5 = {};
            /** @type {any[]} */
            let intermediateResult5 = [];
            /** @type {any|any[]} */
            let intermediateValue5 = value["where"]["idIn"];

            if (!Array.isArray(intermediateValue5)) {
              intermediateValue5 = [intermediateValue5];
            }
            result["where"]["idIn"] = Array.from({
              length: intermediateValue5.length,
            });
            for (let i5 = 0; i5 < intermediateValue5.length; ++i5) {
              if (
                intermediateValue5[i5] === null ||
                intermediateValue5[i5] === undefined
              ) {
                intermediateErrorMap5[`$.${i5}`] = {
                  key: "validator.undefined",
                };
              } else {
                if (
                  typeof intermediateValue5[i5] !== "string" ||
                  (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
                    intermediateValue5[i5],
                  ) &&
                    !/^[a-f0-9]{32}$/gi.test(intermediateValue5[i5]))
                ) {
                  intermediateErrorMap5[`$.${i5}`] = {
                    key: "validator.pattern",
                    patternExplanation: "UUID",
                  };
                } else if (intermediateValue5[i5].length === 32) {
                  intermediateResult5[i5] =
                    intermediateValue5[i5].slice(0, 8) +
                    "-" +
                    intermediateValue5[i5].slice(8, 12) +
                    "-" +
                    intermediateValue5[i5].slice(12, 16) +
                    "-" +
                    intermediateValue5[i5].slice(16, 20) +
                    "-" +
                    intermediateValue5[i5].slice(20);
                } else {
                  intermediateResult5[i5] = intermediateValue5[i5];
                }
              }
            }
            if (Object.keys(intermediateErrorMap5).length) {
              for (const errorKey of Object.keys(intermediateErrorMap5)) {
                errorMap[`$.where.idIn${errorKey.substring(1)}`] =
                  intermediateErrorMap5[errorKey];
              }
            } else {
              result["where"]["idIn"] = intermediateResult5;
            }
          }
          if (
            value["where"]["idNotIn"] === null ||
            value["where"]["idNotIn"] === undefined
          ) {
            errorMap[`$.where.idNotIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap6 = {};
            /** @type {any[]} */
            let intermediateResult6 = [];
            /** @type {any|any[]} */
            let intermediateValue6 = value["where"]["idNotIn"];

            if (!Array.isArray(intermediateValue6)) {
              intermediateValue6 = [intermediateValue6];
            }
            result["where"]["idNotIn"] = Array.from({
              length: intermediateValue6.length,
            });
            for (let i6 = 0; i6 < intermediateValue6.length; ++i6) {
              if (
                intermediateValue6[i6] === null ||
                intermediateValue6[i6] === undefined
              ) {
                intermediateErrorMap6[`$.${i6}`] = {
                  key: "validator.undefined",
                };
              } else {
                if (
                  typeof intermediateValue6[i6] !== "string" ||
                  (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
                    intermediateValue6[i6],
                  ) &&
                    !/^[a-f0-9]{32}$/gi.test(intermediateValue6[i6]))
                ) {
                  intermediateErrorMap6[`$.${i6}`] = {
                    key: "validator.pattern",
                    patternExplanation: "UUID",
                  };
                } else if (intermediateValue6[i6].length === 32) {
                  intermediateResult6[i6] =
                    intermediateValue6[i6].slice(0, 8) +
                    "-" +
                    intermediateValue6[i6].slice(8, 12) +
                    "-" +
                    intermediateValue6[i6].slice(12, 16) +
                    "-" +
                    intermediateValue6[i6].slice(16, 20) +
                    "-" +
                    intermediateValue6[i6].slice(20);
                } else {
                  intermediateResult6[i6] = intermediateValue6[i6];
                }
              }
            }
            if (Object.keys(intermediateErrorMap6).length) {
              for (const errorKey of Object.keys(intermediateErrorMap6)) {
                errorMap[`$.where.idNotIn${errorKey.substring(1)}`] =
                  intermediateErrorMap6[errorKey];
              }
            } else {
              result["where"]["idNotIn"] = intermediateResult6;
            }
          }
          if (
            value["where"]["title"] === null ||
            value["where"]["title"] === undefined
          ) {
            result["where"]["title"] = undefined;
          } else {
            /** @type {string} */
            let convertedString6 = value["where"]["title"];
            if (typeof convertedString6 !== "string") {
              errorMap[`$.where.title`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString6.length === 0) {
                result["where"]["title"] = undefined;
              } else {
                if (convertedString6.length < 1) {
                  errorMap[`$.where.title`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else {
                  result["where"]["title"] = convertedString6;
                }
              }
            }
          }
          if (
            value["where"]["titleNotEqual"] === null ||
            value["where"]["titleNotEqual"] === undefined
          ) {
            result["where"]["titleNotEqual"] = undefined;
          } else {
            /** @type {string} */
            let convertedString7 = value["where"]["titleNotEqual"];
            if (typeof convertedString7 !== "string") {
              errorMap[`$.where.titleNotEqual`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString7.length === 0) {
                result["where"]["titleNotEqual"] = undefined;
              } else {
                if (convertedString7.length < 1) {
                  errorMap[`$.where.titleNotEqual`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else {
                  result["where"]["titleNotEqual"] = convertedString7;
                }
              }
            }
          }
          if (
            value["where"]["titleIn"] === null ||
            value["where"]["titleIn"] === undefined
          ) {
            errorMap[`$.where.titleIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap9 = {};
            /** @type {any[]} */
            let intermediateResult9 = [];
            /** @type {any|any[]} */
            let intermediateValue9 = value["where"]["titleIn"];

            if (!Array.isArray(intermediateValue9)) {
              intermediateValue9 = [intermediateValue9];
            }
            result["where"]["titleIn"] = Array.from({
              length: intermediateValue9.length,
            });
            for (let i9 = 0; i9 < intermediateValue9.length; ++i9) {
              if (
                intermediateValue9[i9] === null ||
                intermediateValue9[i9] === undefined
              ) {
                intermediateErrorMap9[`$.${i9}`] = {
                  key: "validator.undefined",
                };
              } else {
                /** @type {string} */
                let convertedString9 = intermediateValue9[i9];
                if (typeof convertedString9 !== "string") {
                  intermediateErrorMap9[`$.${i9}`] = {
                    key: "validator.string",
                  };
                } else {
                  if (convertedString9.length < 1) {
                    intermediateErrorMap9[`$.${i9}`] = {
                      key: "validator.length",
                      minLength: 1,
                    };
                  } else {
                    intermediateResult9[i9] = convertedString9;
                  }
                }
              }
            }
            if (Object.keys(intermediateErrorMap9).length) {
              for (const errorKey of Object.keys(intermediateErrorMap9)) {
                errorMap[`$.where.titleIn${errorKey.substring(1)}`] =
                  intermediateErrorMap9[errorKey];
              }
            } else {
              result["where"]["titleIn"] = intermediateResult9;
            }
          }
          if (
            value["where"]["titleNotIn"] === null ||
            value["where"]["titleNotIn"] === undefined
          ) {
            errorMap[`$.where.titleNotIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap10 = {};
            /** @type {any[]} */
            let intermediateResult10 = [];
            /** @type {any|any[]} */
            let intermediateValue10 = value["where"]["titleNotIn"];

            if (!Array.isArray(intermediateValue10)) {
              intermediateValue10 = [intermediateValue10];
            }
            result["where"]["titleNotIn"] = Array.from({
              length: intermediateValue10.length,
            });
            for (let i10 = 0; i10 < intermediateValue10.length; ++i10) {
              if (
                intermediateValue10[i10] === null ||
                intermediateValue10[i10] === undefined
              ) {
                intermediateErrorMap10[`$.${i10}`] = {
                  key: "validator.undefined",
                };
              } else {
                /** @type {string} */
                let convertedString10 = intermediateValue10[i10];
                if (typeof convertedString10 !== "string") {
                  intermediateErrorMap10[`$.${i10}`] = {
                    key: "validator.string",
                  };
                } else {
                  if (convertedString10.length < 1) {
                    intermediateErrorMap10[`$.${i10}`] = {
                      key: "validator.length",
                      minLength: 1,
                    };
                  } else {
                    intermediateResult10[i10] = convertedString10;
                  }
                }
              }
            }
            if (Object.keys(intermediateErrorMap10).length) {
              for (const errorKey of Object.keys(intermediateErrorMap10)) {
                errorMap[`$.where.titleNotIn${errorKey.substring(1)}`] =
                  intermediateErrorMap10[errorKey];
              }
            } else {
              result["where"]["titleNotIn"] = intermediateResult10;
            }
          }
          if (
            value["where"]["titleLike"] === null ||
            value["where"]["titleLike"] === undefined
          ) {
            result["where"]["titleLike"] = undefined;
          } else {
            /** @type {string} */
            let convertedString10 = value["where"]["titleLike"];
            if (typeof convertedString10 !== "string") {
              errorMap[`$.where.titleLike`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString10.length === 0) {
                result["where"]["titleLike"] = undefined;
              } else {
                if (convertedString10.length < 1) {
                  errorMap[`$.where.titleLike`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else {
                  result["where"]["titleLike"] = convertedString10;
                }
              }
            }
          }
          if (
            value["where"]["titleILike"] === null ||
            value["where"]["titleILike"] === undefined
          ) {
            result["where"]["titleILike"] = undefined;
          } else {
            /** @type {string} */
            let convertedString11 = value["where"]["titleILike"];
            if (typeof convertedString11 !== "string") {
              errorMap[`$.where.titleILike`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString11.length === 0) {
                result["where"]["titleILike"] = undefined;
              } else {
                if (convertedString11.length < 1) {
                  errorMap[`$.where.titleILike`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else {
                  result["where"]["titleILike"] = convertedString11;
                }
              }
            }
          }
          if (
            value["where"]["titleNotLike"] === null ||
            value["where"]["titleNotLike"] === undefined
          ) {
            result["where"]["titleNotLike"] = undefined;
          } else {
            /** @type {string} */
            let convertedString12 = value["where"]["titleNotLike"];
            if (typeof convertedString12 !== "string") {
              errorMap[`$.where.titleNotLike`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString12.length === 0) {
                result["where"]["titleNotLike"] = undefined;
              } else {
                if (convertedString12.length < 1) {
                  errorMap[`$.where.titleNotLike`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else {
                  result["where"]["titleNotLike"] = convertedString12;
                }
              }
            }
          }
          if (
            value["where"]["createdAt"] === null ||
            value["where"]["createdAt"] === undefined
          ) {
            result["where"]["createdAt"] = undefined;
          } else {
            if (
              typeof value["where"]["createdAt"] === "string" ||
              typeof value["where"]["createdAt"] === "number"
            ) {
              result["where"]["createdAt"] = new Date(
                value["where"]["createdAt"],
              );
            } else if (
              Object.prototype.toString.call(value["where"]["createdAt"]) ===
              "[object Date]"
            ) {
              result["where"]["createdAt"] = value["where"]["createdAt"];
            } else {
              errorMap[`$.where.createdAt`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (isNaN(result["where"]["createdAt"]?.getTime() ?? undefined)) {
              errorMap[`$.where.createdAt`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["createdAtNotEqual"] === null ||
            value["where"]["createdAtNotEqual"] === undefined
          ) {
            result["where"]["createdAtNotEqual"] = undefined;
          } else {
            if (
              typeof value["where"]["createdAtNotEqual"] === "string" ||
              typeof value["where"]["createdAtNotEqual"] === "number"
            ) {
              result["where"]["createdAtNotEqual"] = new Date(
                value["where"]["createdAtNotEqual"],
              );
            } else if (
              Object.prototype.toString.call(
                value["where"]["createdAtNotEqual"],
              ) === "[object Date]"
            ) {
              result["where"]["createdAtNotEqual"] =
                value["where"]["createdAtNotEqual"];
            } else {
              errorMap[`$.where.createdAtNotEqual`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (
              isNaN(
                result["where"]["createdAtNotEqual"]?.getTime() ?? undefined,
              )
            ) {
              errorMap[`$.where.createdAtNotEqual`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["createdAtIn"] === null ||
            value["where"]["createdAtIn"] === undefined
          ) {
            errorMap[`$.where.createdAtIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap16 = {};
            /** @type {any[]} */
            let intermediateResult16 = [];
            /** @type {any|any[]} */
            let intermediateValue16 = value["where"]["createdAtIn"];

            if (!Array.isArray(intermediateValue16)) {
              intermediateValue16 = [intermediateValue16];
            }
            result["where"]["createdAtIn"] = Array.from({
              length: intermediateValue16.length,
            });
            for (let i16 = 0; i16 < intermediateValue16.length; ++i16) {
              if (
                intermediateValue16[i16] === null ||
                intermediateValue16[i16] === undefined
              ) {
                intermediateErrorMap16[`$.${i16}`] = {
                  key: "validator.undefined",
                };
              } else {
                if (
                  typeof intermediateValue16[i16] === "string" ||
                  typeof intermediateValue16[i16] === "number"
                ) {
                  intermediateResult16[i16] = new Date(
                    intermediateValue16[i16],
                  );
                } else if (
                  Object.prototype.toString.call(intermediateValue16[i16]) ===
                  "[object Date]"
                ) {
                  intermediateResult16[i16] = intermediateValue16[i16];
                } else {
                  intermediateErrorMap16[`$.${i16}`] = {
                    key: "validator.type",
                    expectedType: "Date|string",
                  };
                }
                if (isNaN(intermediateResult16[i16]?.getTime() ?? undefined)) {
                  intermediateErrorMap16[`$.${i16}`] = {
                    key: "validator.date.invalid",
                  };
                }
              }
            }
            if (Object.keys(intermediateErrorMap16).length) {
              for (const errorKey of Object.keys(intermediateErrorMap16)) {
                errorMap[`$.where.createdAtIn${errorKey.substring(1)}`] =
                  intermediateErrorMap16[errorKey];
              }
            } else {
              result["where"]["createdAtIn"] = intermediateResult16;
            }
          }
          if (
            value["where"]["createdAtNotIn"] === null ||
            value["where"]["createdAtNotIn"] === undefined
          ) {
            errorMap[`$.where.createdAtNotIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap17 = {};
            /** @type {any[]} */
            let intermediateResult17 = [];
            /** @type {any|any[]} */
            let intermediateValue17 = value["where"]["createdAtNotIn"];

            if (!Array.isArray(intermediateValue17)) {
              intermediateValue17 = [intermediateValue17];
            }
            result["where"]["createdAtNotIn"] = Array.from({
              length: intermediateValue17.length,
            });
            for (let i17 = 0; i17 < intermediateValue17.length; ++i17) {
              if (
                intermediateValue17[i17] === null ||
                intermediateValue17[i17] === undefined
              ) {
                intermediateErrorMap17[`$.${i17}`] = {
                  key: "validator.undefined",
                };
              } else {
                if (
                  typeof intermediateValue17[i17] === "string" ||
                  typeof intermediateValue17[i17] === "number"
                ) {
                  intermediateResult17[i17] = new Date(
                    intermediateValue17[i17],
                  );
                } else if (
                  Object.prototype.toString.call(intermediateValue17[i17]) ===
                  "[object Date]"
                ) {
                  intermediateResult17[i17] = intermediateValue17[i17];
                } else {
                  intermediateErrorMap17[`$.${i17}`] = {
                    key: "validator.type",
                    expectedType: "Date|string",
                  };
                }
                if (isNaN(intermediateResult17[i17]?.getTime() ?? undefined)) {
                  intermediateErrorMap17[`$.${i17}`] = {
                    key: "validator.date.invalid",
                  };
                }
              }
            }
            if (Object.keys(intermediateErrorMap17).length) {
              for (const errorKey of Object.keys(intermediateErrorMap17)) {
                errorMap[`$.where.createdAtNotIn${errorKey.substring(1)}`] =
                  intermediateErrorMap17[errorKey];
              }
            } else {
              result["where"]["createdAtNotIn"] = intermediateResult17;
            }
          }
          if (
            value["where"]["createdAtGreaterThan"] === null ||
            value["where"]["createdAtGreaterThan"] === undefined
          ) {
            result["where"]["createdAtGreaterThan"] = undefined;
          } else {
            if (
              typeof value["where"]["createdAtGreaterThan"] === "string" ||
              typeof value["where"]["createdAtGreaterThan"] === "number"
            ) {
              result["where"]["createdAtGreaterThan"] = new Date(
                value["where"]["createdAtGreaterThan"],
              );
            } else if (
              Object.prototype.toString.call(
                value["where"]["createdAtGreaterThan"],
              ) === "[object Date]"
            ) {
              result["where"]["createdAtGreaterThan"] =
                value["where"]["createdAtGreaterThan"];
            } else {
              errorMap[`$.where.createdAtGreaterThan`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (
              isNaN(
                result["where"]["createdAtGreaterThan"]?.getTime() ?? undefined,
              )
            ) {
              errorMap[`$.where.createdAtGreaterThan`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["createdAtLowerThan"] === null ||
            value["where"]["createdAtLowerThan"] === undefined
          ) {
            result["where"]["createdAtLowerThan"] = undefined;
          } else {
            if (
              typeof value["where"]["createdAtLowerThan"] === "string" ||
              typeof value["where"]["createdAtLowerThan"] === "number"
            ) {
              result["where"]["createdAtLowerThan"] = new Date(
                value["where"]["createdAtLowerThan"],
              );
            } else if (
              Object.prototype.toString.call(
                value["where"]["createdAtLowerThan"],
              ) === "[object Date]"
            ) {
              result["where"]["createdAtLowerThan"] =
                value["where"]["createdAtLowerThan"];
            } else {
              errorMap[`$.where.createdAtLowerThan`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (
              isNaN(
                result["where"]["createdAtLowerThan"]?.getTime() ?? undefined,
              )
            ) {
              errorMap[`$.where.createdAtLowerThan`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["updatedAt"] === null ||
            value["where"]["updatedAt"] === undefined
          ) {
            result["where"]["updatedAt"] = undefined;
          } else {
            if (
              typeof value["where"]["updatedAt"] === "string" ||
              typeof value["where"]["updatedAt"] === "number"
            ) {
              result["where"]["updatedAt"] = new Date(
                value["where"]["updatedAt"],
              );
            } else if (
              Object.prototype.toString.call(value["where"]["updatedAt"]) ===
              "[object Date]"
            ) {
              result["where"]["updatedAt"] = value["where"]["updatedAt"];
            } else {
              errorMap[`$.where.updatedAt`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (isNaN(result["where"]["updatedAt"]?.getTime() ?? undefined)) {
              errorMap[`$.where.updatedAt`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["updatedAtNotEqual"] === null ||
            value["where"]["updatedAtNotEqual"] === undefined
          ) {
            result["where"]["updatedAtNotEqual"] = undefined;
          } else {
            if (
              typeof value["where"]["updatedAtNotEqual"] === "string" ||
              typeof value["where"]["updatedAtNotEqual"] === "number"
            ) {
              result["where"]["updatedAtNotEqual"] = new Date(
                value["where"]["updatedAtNotEqual"],
              );
            } else if (
              Object.prototype.toString.call(
                value["where"]["updatedAtNotEqual"],
              ) === "[object Date]"
            ) {
              result["where"]["updatedAtNotEqual"] =
                value["where"]["updatedAtNotEqual"];
            } else {
              errorMap[`$.where.updatedAtNotEqual`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (
              isNaN(
                result["where"]["updatedAtNotEqual"]?.getTime() ?? undefined,
              )
            ) {
              errorMap[`$.where.updatedAtNotEqual`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["updatedAtIn"] === null ||
            value["where"]["updatedAtIn"] === undefined
          ) {
            errorMap[`$.where.updatedAtIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap22 = {};
            /** @type {any[]} */
            let intermediateResult22 = [];
            /** @type {any|any[]} */
            let intermediateValue22 = value["where"]["updatedAtIn"];

            if (!Array.isArray(intermediateValue22)) {
              intermediateValue22 = [intermediateValue22];
            }
            result["where"]["updatedAtIn"] = Array.from({
              length: intermediateValue22.length,
            });
            for (let i22 = 0; i22 < intermediateValue22.length; ++i22) {
              if (
                intermediateValue22[i22] === null ||
                intermediateValue22[i22] === undefined
              ) {
                intermediateErrorMap22[`$.${i22}`] = {
                  key: "validator.undefined",
                };
              } else {
                if (
                  typeof intermediateValue22[i22] === "string" ||
                  typeof intermediateValue22[i22] === "number"
                ) {
                  intermediateResult22[i22] = new Date(
                    intermediateValue22[i22],
                  );
                } else if (
                  Object.prototype.toString.call(intermediateValue22[i22]) ===
                  "[object Date]"
                ) {
                  intermediateResult22[i22] = intermediateValue22[i22];
                } else {
                  intermediateErrorMap22[`$.${i22}`] = {
                    key: "validator.type",
                    expectedType: "Date|string",
                  };
                }
                if (isNaN(intermediateResult22[i22]?.getTime() ?? undefined)) {
                  intermediateErrorMap22[`$.${i22}`] = {
                    key: "validator.date.invalid",
                  };
                }
              }
            }
            if (Object.keys(intermediateErrorMap22).length) {
              for (const errorKey of Object.keys(intermediateErrorMap22)) {
                errorMap[`$.where.updatedAtIn${errorKey.substring(1)}`] =
                  intermediateErrorMap22[errorKey];
              }
            } else {
              result["where"]["updatedAtIn"] = intermediateResult22;
            }
          }
          if (
            value["where"]["updatedAtNotIn"] === null ||
            value["where"]["updatedAtNotIn"] === undefined
          ) {
            errorMap[`$.where.updatedAtNotIn`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {ValidatorErrorMap} */
            const intermediateErrorMap23 = {};
            /** @type {any[]} */
            let intermediateResult23 = [];
            /** @type {any|any[]} */
            let intermediateValue23 = value["where"]["updatedAtNotIn"];

            if (!Array.isArray(intermediateValue23)) {
              intermediateValue23 = [intermediateValue23];
            }
            result["where"]["updatedAtNotIn"] = Array.from({
              length: intermediateValue23.length,
            });
            for (let i23 = 0; i23 < intermediateValue23.length; ++i23) {
              if (
                intermediateValue23[i23] === null ||
                intermediateValue23[i23] === undefined
              ) {
                intermediateErrorMap23[`$.${i23}`] = {
                  key: "validator.undefined",
                };
              } else {
                if (
                  typeof intermediateValue23[i23] === "string" ||
                  typeof intermediateValue23[i23] === "number"
                ) {
                  intermediateResult23[i23] = new Date(
                    intermediateValue23[i23],
                  );
                } else if (
                  Object.prototype.toString.call(intermediateValue23[i23]) ===
                  "[object Date]"
                ) {
                  intermediateResult23[i23] = intermediateValue23[i23];
                } else {
                  intermediateErrorMap23[`$.${i23}`] = {
                    key: "validator.type",
                    expectedType: "Date|string",
                  };
                }
                if (isNaN(intermediateResult23[i23]?.getTime() ?? undefined)) {
                  intermediateErrorMap23[`$.${i23}`] = {
                    key: "validator.date.invalid",
                  };
                }
              }
            }
            if (Object.keys(intermediateErrorMap23).length) {
              for (const errorKey of Object.keys(intermediateErrorMap23)) {
                errorMap[`$.where.updatedAtNotIn${errorKey.substring(1)}`] =
                  intermediateErrorMap23[errorKey];
              }
            } else {
              result["where"]["updatedAtNotIn"] = intermediateResult23;
            }
          }
          if (
            value["where"]["updatedAtGreaterThan"] === null ||
            value["where"]["updatedAtGreaterThan"] === undefined
          ) {
            result["where"]["updatedAtGreaterThan"] = undefined;
          } else {
            if (
              typeof value["where"]["updatedAtGreaterThan"] === "string" ||
              typeof value["where"]["updatedAtGreaterThan"] === "number"
            ) {
              result["where"]["updatedAtGreaterThan"] = new Date(
                value["where"]["updatedAtGreaterThan"],
              );
            } else if (
              Object.prototype.toString.call(
                value["where"]["updatedAtGreaterThan"],
              ) === "[object Date]"
            ) {
              result["where"]["updatedAtGreaterThan"] =
                value["where"]["updatedAtGreaterThan"];
            } else {
              errorMap[`$.where.updatedAtGreaterThan`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (
              isNaN(
                result["where"]["updatedAtGreaterThan"]?.getTime() ?? undefined,
              )
            ) {
              errorMap[`$.where.updatedAtGreaterThan`] = {
                key: "validator.date.invalid",
              };
            }
          }
          if (
            value["where"]["updatedAtLowerThan"] === null ||
            value["where"]["updatedAtLowerThan"] === undefined
          ) {
            result["where"]["updatedAtLowerThan"] = undefined;
          } else {
            if (
              typeof value["where"]["updatedAtLowerThan"] === "string" ||
              typeof value["where"]["updatedAtLowerThan"] === "number"
            ) {
              result["where"]["updatedAtLowerThan"] = new Date(
                value["where"]["updatedAtLowerThan"],
              );
            } else if (
              Object.prototype.toString.call(
                value["where"]["updatedAtLowerThan"],
              ) === "[object Date]"
            ) {
              result["where"]["updatedAtLowerThan"] =
                value["where"]["updatedAtLowerThan"];
            } else {
              errorMap[`$.where.updatedAtLowerThan`] = {
                key: "validator.type",
                expectedType: "Date|string",
              };
            }
            if (
              isNaN(
                result["where"]["updatedAtLowerThan"]?.getTime() ?? undefined,
              )
            ) {
              errorMap[`$.where.updatedAtLowerThan`] = {
                key: "validator.date.invalid",
              };
            }
          }
        }
      }
      if (value["orderBy"] === null || value["orderBy"] === undefined) {
        result["orderBy"] = undefined;
      } else {
        /** @type {ValidatorErrorMap} */
        const intermediateErrorMap3 = {};
        /** @type {any[]} */
        let intermediateResult3 = [];
        /** @type {any|any[]} */
        let intermediateValue3 = value["orderBy"];

        if (!Array.isArray(intermediateValue3)) {
          intermediateValue3 = [intermediateValue3];
        }
        result["orderBy"] = Array.from({ length: intermediateValue3.length });
        for (let i3 = 0; i3 < intermediateValue3.length; ++i3) {
          if (
            intermediateValue3[i3] === null ||
            intermediateValue3[i3] === undefined
          ) {
            intermediateErrorMap3[`$.${i3}`] = {
              key: "validator.undefined",
            };
          } else {
            /** @type {string} */
            let convertedString3 = intermediateValue3[i3];
            if (typeof convertedString3 !== "string") {
              intermediateErrorMap3[`$.${i3}`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString3.length < 1) {
                intermediateErrorMap3[`$.${i3}`] = {
                  key: "validator.length",
                  minLength: 1,
                };
              } else if (
                convertedString3 !== "id" &&
                convertedString3 !== "title" &&
                convertedString3 !== "createdAt" &&
                convertedString3 !== "updatedAt"
              ) {
                intermediateErrorMap3[`$.${i3}`] = {
                  key: "validator.oneOf",
                  allowedValues: ["id", "title", "createdAt", "updatedAt"],
                  foundValue: convertedString3,
                };
              } else {
                intermediateResult3[i3] = convertedString3;
              }
            }
          }
        }
        if (Object.keys(intermediateErrorMap3).length) {
          for (const errorKey of Object.keys(intermediateErrorMap3)) {
            errorMap[`$.orderBy${errorKey.substring(1)}`] =
              intermediateErrorMap3[errorKey];
          }
        } else {
          result["orderBy"] = intermediateResult3;
        }
      }
      if (value["orderBySpec"] === null || value["orderBySpec"] === undefined) {
        result["orderBySpec"] = undefined;
      } else {
        if (
          typeof value["orderBySpec"] !== "object" ||
          Array.isArray(value["orderBySpec"])
        ) {
          errorMap[`$.orderBySpec`] = {
            key: "validator.object",
            value: value["orderBySpec"],
            foundType: typeof value["orderBySpec"],
          };
        } else {
          /** @type {Set<string>} */
          const knownKeys3 = new Set(["id", "title", "createdAt", "updatedAt"]);
          for (const key of Object.keys(value["orderBySpec"])) {
            if (
              !knownKeys3.has(key) &&
              value["orderBySpec"][key] !== null &&
              value["orderBySpec"][key] !== undefined
            ) {
              const expectedKeys = [...knownKeys3];
              const foundKeys = Object.keys(value["orderBySpec"]);
              const unknownKeys = foundKeys.filter((it) => !knownKeys3.has(it));
              errorMap[`$.orderBySpec`] = {
                key: "validator.keys",
                unknownKeys,
                expectedKeys,
                foundKeys,
              };
              break;
            }
          }
          result["orderBySpec"] = Object.create(null);

          if (
            value["orderBySpec"]["id"] === null ||
            value["orderBySpec"]["id"] === undefined
          ) {
            result["orderBySpec"]["id"] = undefined;
          } else {
            /** @type {string} */
            let convertedString4 = value["orderBySpec"]["id"];
            if (typeof convertedString4 !== "string") {
              errorMap[`$.orderBySpec.id`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString4.length === 0) {
                result["orderBySpec"]["id"] = undefined;
              } else {
                if (convertedString4.length < 1) {
                  errorMap[`$.orderBySpec.id`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else if (
                  convertedString4 !== "ASC" &&
                  convertedString4 !== "DESC"
                ) {
                  errorMap[`$.orderBySpec.id`] = {
                    key: "validator.oneOf",
                    allowedValues: ["ASC", "DESC"],
                    foundValue: convertedString4,
                  };
                } else {
                  result["orderBySpec"]["id"] = convertedString4;
                }
              }
            }
          }
          if (
            value["orderBySpec"]["title"] === null ||
            value["orderBySpec"]["title"] === undefined
          ) {
            result["orderBySpec"]["title"] = undefined;
          } else {
            /** @type {string} */
            let convertedString5 = value["orderBySpec"]["title"];
            if (typeof convertedString5 !== "string") {
              errorMap[`$.orderBySpec.title`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString5.length === 0) {
                result["orderBySpec"]["title"] = undefined;
              } else {
                if (convertedString5.length < 1) {
                  errorMap[`$.orderBySpec.title`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else if (
                  convertedString5 !== "ASC" &&
                  convertedString5 !== "DESC"
                ) {
                  errorMap[`$.orderBySpec.title`] = {
                    key: "validator.oneOf",
                    allowedValues: ["ASC", "DESC"],
                    foundValue: convertedString5,
                  };
                } else {
                  result["orderBySpec"]["title"] = convertedString5;
                }
              }
            }
          }
          if (
            value["orderBySpec"]["createdAt"] === null ||
            value["orderBySpec"]["createdAt"] === undefined
          ) {
            result["orderBySpec"]["createdAt"] = undefined;
          } else {
            /** @type {string} */
            let convertedString6 = value["orderBySpec"]["createdAt"];
            if (typeof convertedString6 !== "string") {
              errorMap[`$.orderBySpec.createdAt`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString6.length === 0) {
                result["orderBySpec"]["createdAt"] = undefined;
              } else {
                if (convertedString6.length < 1) {
                  errorMap[`$.orderBySpec.createdAt`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else if (
                  convertedString6 !== "ASC" &&
                  convertedString6 !== "DESC"
                ) {
                  errorMap[`$.orderBySpec.createdAt`] = {
                    key: "validator.oneOf",
                    allowedValues: ["ASC", "DESC"],
                    foundValue: convertedString6,
                  };
                } else {
                  result["orderBySpec"]["createdAt"] = convertedString6;
                }
              }
            }
          }
          if (
            value["orderBySpec"]["updatedAt"] === null ||
            value["orderBySpec"]["updatedAt"] === undefined
          ) {
            result["orderBySpec"]["updatedAt"] = undefined;
          } else {
            /** @type {string} */
            let convertedString7 = value["orderBySpec"]["updatedAt"];
            if (typeof convertedString7 !== "string") {
              errorMap[`$.orderBySpec.updatedAt`] = {
                key: "validator.string",
              };
            } else {
              if (convertedString7.length === 0) {
                result["orderBySpec"]["updatedAt"] = undefined;
              } else {
                if (convertedString7.length < 1) {
                  errorMap[`$.orderBySpec.updatedAt`] = {
                    key: "validator.length",
                    minLength: 1,
                  };
                } else if (
                  convertedString7 !== "ASC" &&
                  convertedString7 !== "DESC"
                ) {
                  errorMap[`$.orderBySpec.updatedAt`] = {
                    key: "validator.oneOf",
                    allowedValues: ["ASC", "DESC"],
                    foundValue: convertedString7,
                  };
                } else {
                  result["orderBySpec"]["updatedAt"] = convertedString7;
                }
              }
            }
          }
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostListResponse|any} value
 * @returns {Either<import("../common/types").PostListResponseRouterValidated, ValidatorErrorMap>}
 */
export function validatePostListResponseRouterValidated(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["list", "total"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["list"] === null || value["list"] === undefined) {
        errorMap[`$.list`] = {
          key: "validator.undefined",
        };
      } else {
        /** @type {ValidatorErrorMap} */
        const intermediateErrorMap2 = {};
        /** @type {any[]} */
        let intermediateResult2 = [];
        /** @type {any|any[]} */
        let intermediateValue2 = value["list"];

        if (!Array.isArray(intermediateValue2)) {
          intermediateValue2 = [intermediateValue2];
        }
        result["list"] = Array.from({ length: intermediateValue2.length });
        for (let i2 = 0; i2 < intermediateValue2.length; ++i2) {
          if (
            intermediateValue2[i2] === null ||
            intermediateValue2[i2] === undefined
          ) {
            intermediateErrorMap2[`$.${i2}`] = {
              key: "validator.undefined",
            };
          } else {
            const refResult2 = validatePostItemRouterValidated(
              intermediateValue2[i2],
            );

            if (refResult2.error) {
              for (const errorKey of Object.keys(refResult2.error)) {
                intermediateErrorMap2[`$.${i2}${errorKey.substring(1)}`] =
                  refResult2.error[errorKey];
              }
            }
            intermediateResult2[i2] = refResult2.value;
          }
        }
        if (Object.keys(intermediateErrorMap2).length) {
          for (const errorKey of Object.keys(intermediateErrorMap2)) {
            errorMap[`$.list${errorKey.substring(1)}`] =
              intermediateErrorMap2[errorKey];
          }
        } else {
          result["list"] = intermediateResult2;
        }
      }
      if (value["total"] === null || value["total"] === undefined) {
        errorMap[`$.total`] = {
          key: "validator.undefined",
        };
      } else {
        let convertedNumber2 = value["total"];
        if (
          typeof convertedNumber2 !== "number" &&
          typeof convertedNumber2 === "string"
        ) {
          convertedNumber2 = Number(convertedNumber2);
        }
        if (
          typeof convertedNumber2 !== "number" ||
          isNaN(convertedNumber2) ||
          !isFinite(convertedNumber2) ||
          !Number.isInteger(convertedNumber2)
        ) {
          errorMap[`$.total`] = {
            key: "validator.number",
            subType: "int",
          };
        } else if (convertedNumber2 < -2147483647) {
          errorMap[`$.total`] = {
            key: "validator.range",
            minValue: -2147483647,
          };
        } else if (convertedNumber2 > 2147483647) {
          errorMap[`$.total`] = {
            key: "validator.range",
            maxValue: 2147483647,
          };
        } else {
          result["total"] = convertedNumber2;
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostItem|any} value
 * @returns {Either<import("../common/types").PostItemRouterValidated, ValidatorErrorMap>}
 */
export function validatePostItemRouterValidated(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set([
        "id",
        "text",
        "title",
        "createdAt",
        "updatedAt",
      ]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["id"] === null || value["id"] === undefined) {
        errorMap[`$.id`] = {
          key: "validator.undefined",
        };
      } else {
        if (
          typeof value["id"] !== "string" ||
          (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
            value["id"],
          ) &&
            !/^[a-f0-9]{32}$/gi.test(value["id"]))
        ) {
          errorMap[`$.id`] = {
            key: "validator.pattern",
            patternExplanation: "UUID",
          };
        } else if (value["id"].length === 32) {
          result["id"] =
            value["id"].slice(0, 8) +
            "-" +
            value["id"].slice(8, 12) +
            "-" +
            value["id"].slice(12, 16) +
            "-" +
            value["id"].slice(16, 20) +
            "-" +
            value["id"].slice(20);
        } else {
          result["id"] = value["id"];
        }
      }
      if (value["text"] === null || value["text"] === undefined) {
        errorMap[`$.text`] = {
          key: "validator.undefined",
        };
      } else {
        /** @type {string} */
        let convertedString2 = value["text"];
        if (typeof convertedString2 !== "string") {
          errorMap[`$.text`] = {
            key: "validator.string",
          };
        } else {
          if (convertedString2.length < 1) {
            errorMap[`$.text`] = {
              key: "validator.length",
              minLength: 1,
            };
          } else {
            result["text"] = convertedString2;
          }
        }
      }
      if (value["title"] === null || value["title"] === undefined) {
        errorMap[`$.title`] = {
          key: "validator.undefined",
        };
      } else {
        /** @type {string} */
        let convertedString3 = value["title"];
        if (typeof convertedString3 !== "string") {
          errorMap[`$.title`] = {
            key: "validator.string",
          };
        } else {
          if (convertedString3.length < 1) {
            errorMap[`$.title`] = {
              key: "validator.length",
              minLength: 1,
            };
          } else {
            result["title"] = convertedString3;
          }
        }
      }
      if (value["createdAt"] === null || value["createdAt"] === undefined) {
        errorMap[`$.createdAt`] = {
          key: "validator.undefined",
        };
      } else {
        if (
          typeof value["createdAt"] === "string" ||
          typeof value["createdAt"] === "number"
        ) {
          result["createdAt"] = new Date(value["createdAt"]);
        } else if (
          Object.prototype.toString.call(value["createdAt"]) === "[object Date]"
        ) {
          result["createdAt"] = value["createdAt"];
        } else {
          errorMap[`$.createdAt`] = {
            key: "validator.type",
            expectedType: "Date|string",
          };
        }
        if (isNaN(result["createdAt"]?.getTime() ?? undefined)) {
          errorMap[`$.createdAt`] = {
            key: "validator.date.invalid",
          };
        }
      }
      if (value["updatedAt"] === null || value["updatedAt"] === undefined) {
        errorMap[`$.updatedAt`] = {
          key: "validator.undefined",
        };
      } else {
        if (
          typeof value["updatedAt"] === "string" ||
          typeof value["updatedAt"] === "number"
        ) {
          result["updatedAt"] = new Date(value["updatedAt"]);
        } else if (
          Object.prototype.toString.call(value["updatedAt"]) === "[object Date]"
        ) {
          result["updatedAt"] = value["updatedAt"];
        } else {
          errorMap[`$.updatedAt`] = {
            key: "validator.type",
            expectedType: "Date|string",
          };
        }
        if (isNaN(result["updatedAt"]?.getTime() ?? undefined)) {
          errorMap[`$.updatedAt`] = {
            key: "validator.date.invalid",
          };
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostSingleParams|any} value
 * @returns {Either<import("../common/types").PostSingleParams, ValidatorErrorMap>}
 */
export function validatePostSingleParams(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["postId"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["postId"] === null || value["postId"] === undefined) {
        errorMap[`$.postId`] = {
          key: "validator.undefined",
        };
      } else {
        if (
          typeof value["postId"] !== "string" ||
          (!/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/gi.test(
            value["postId"],
          ) &&
            !/^[a-f0-9]{32}$/gi.test(value["postId"]))
        ) {
          errorMap[`$.postId`] = {
            key: "validator.pattern",
            patternExplanation: "UUID",
          };
        } else if (value["postId"].length === 32) {
          result["postId"] =
            value["postId"].slice(0, 8) +
            "-" +
            value["postId"].slice(8, 12) +
            "-" +
            value["postId"].slice(12, 16) +
            "-" +
            value["postId"].slice(16, 20) +
            "-" +
            value["postId"].slice(20);
        } else {
          result["postId"] = value["postId"];
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostSingleResponse|any} value
 * @returns {Either<import("../common/types").PostSingleResponseRouterValidated, ValidatorErrorMap>}
 */
export function validatePostSingleResponseRouterValidated(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["item"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["item"] === null || value["item"] === undefined) {
        errorMap[`$.item`] = {
          key: "validator.undefined",
        };
      } else {
        const refResult1 = validatePostItemRouterValidated(value["item"]);

        if (refResult1.error) {
          for (const errorKey of Object.keys(refResult1.error)) {
            errorMap[`$.item${errorKey.substring(1)}`] =
              refResult1.error[errorKey];
          }
        }
        result["item"] = refResult1.value;
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostItemWrite|any} value
 * @returns {Either<import("../common/types").PostItemWrite, ValidatorErrorMap>}
 */
export function validatePostItemWrite(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["text", "title"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["text"] === null || value["text"] === undefined) {
        errorMap[`$.text`] = {
          key: "validator.undefined",
        };
      } else {
        /** @type {string} */
        let convertedString1 = value["text"];
        if (typeof convertedString1 !== "string") {
          errorMap[`$.text`] = {
            key: "validator.string",
          };
        } else {
          if (convertedString1.length < 1) {
            errorMap[`$.text`] = {
              key: "validator.length",
              minLength: 1,
            };
          } else {
            result["text"] = convertedString1;
          }
        }
      }
      if (value["title"] === null || value["title"] === undefined) {
        errorMap[`$.title`] = {
          key: "validator.undefined",
        };
      } else {
        /** @type {string} */
        let convertedString2 = value["title"];
        if (typeof convertedString2 !== "string") {
          errorMap[`$.title`] = {
            key: "validator.string",
          };
        } else {
          if (convertedString2.length < 1) {
            errorMap[`$.title`] = {
              key: "validator.length",
              minLength: 1,
            };
          } else {
            result["title"] = convertedString2;
          }
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types").PostCreateResponse|any} value
 * @returns {Either<import("../common/types").PostCreateResponseRouterValidated, ValidatorErrorMap>}
 */
export function validatePostCreateResponseRouterValidated(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (typeof value !== "object" || Array.isArray(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["item"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = Object.create(null);

      if (value["item"] === null || value["item"] === undefined) {
        errorMap[`$.item`] = {
          key: "validator.undefined",
        };
      } else {
        const refResult1 = validatePostItemRouterValidated(value["item"]);

        if (refResult1.error) {
          for (const errorKey of Object.keys(refResult1.error)) {
            errorMap[`$.item${errorKey.substring(1)}`] =
              refResult1.error[errorKey];
          }
        }
        result["item"] = refResult1.value;
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}
