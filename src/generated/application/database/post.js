// Generated by @compas/code-gen

import { wrapQueryPart } from "../common/database-helpers.js";
import {
  validateDatabasePost,
  validateDatabasePostInsertValidated,
  validateDatabasePostOrderBySpec,
  validateDatabasePostOrderByValidated,
  validateDatabasePostQueryBuilderValidated,
  validateDatabasePostUpdateValidated,
  validateDatabasePostWhereValidated,
} from "../database/validators.js";
import { validateQueryResultDatabasePost } from "../queryResult/validators.js";
import { AppError, isNil } from "@compas/stdlib";
import {
  generatedQueryBuilderHelper,
  generatedUpdateHelper,
  generatedWhereBuilderHelper,
  isQueryPart,
  query,
} from "@compas/store";

export const postQueries = {
  postCount,
  postInsert,
  postUpdate,
  postDelete,
  postUpsertOnId,
};

/** @type {any} */
export const postWhereSpec = {
  fieldSpecification: [
    {
      tableKey: "id",
      keyType: "uuid",
      matchers: [
        {
          matcherKey: "id",
          matcherType: "equal",
        },
        {
          matcherKey: "idNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "idIn",
          matcherType: "in",
        },
        {
          matcherKey: "idNotIn",
          matcherType: "notIn",
        },
      ],
    },
    {
      tableKey: "title",
      keyType: "varchar",
      matchers: [
        {
          matcherKey: "title",
          matcherType: "equal",
        },
        {
          matcherKey: "titleNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "titleIn",
          matcherType: "in",
        },
        {
          matcherKey: "titleNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "titleLike",
          matcherType: "like",
        },
        {
          matcherKey: "titleILike",
          matcherType: "iLike",
        },
        {
          matcherKey: "titleNotLike",
          matcherType: "notLike",
        },
      ],
    },
    {
      tableKey: "createdAt",
      keyType: "timestamptz",
      matchers: [
        {
          matcherKey: "createdAt",
          matcherType: "equal",
        },
        {
          matcherKey: "createdAtNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "createdAtIn",
          matcherType: "in",
        },
        {
          matcherKey: "createdAtNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "createdAtGreaterThan",
          matcherType: "greaterThan",
        },
        {
          matcherKey: "createdAtLowerThan",
          matcherType: "lowerThan",
        },
      ],
    },
    {
      tableKey: "updatedAt",
      keyType: "timestamptz",
      matchers: [
        {
          matcherKey: "updatedAt",
          matcherType: "equal",
        },
        {
          matcherKey: "updatedAtNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "updatedAtIn",
          matcherType: "in",
        },
        {
          matcherKey: "updatedAtNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "updatedAtGreaterThan",
          matcherType: "greaterThan",
        },
        {
          matcherKey: "updatedAtLowerThan",
          matcherType: "lowerThan",
        },
      ],
    },
  ],
};

/**
 * Reusable where clause generator. This is used by other generated queries, and can be used inline in custom queries.
 *
 * @param {import("../common/types").DatabasePostWhere} [where]
 * @param {{ skipValidator?: boolean, shortName?: string }} [options]
 * @returns {QueryPart<any>}
 */
export function postWhere(where, options = {}) {
  options.shortName ??= "p.";
  if (!options.shortName.endsWith(".")) {
    options.shortName += ".";
  }
  if (!options.skipValidator) {
    const { error, value } = validateDatabasePostWhereValidated(where ?? {});
    if (error) {
      throw AppError.serverError({ message: "Invalid where object", error });
    }
    where = value;
  }
  return generatedWhereBuilderHelper(
    postWhereSpec,
    where ?? {},
    options.shortName,
  );
}

/**
 * Reusable ORDER BY clause generator. This is used by other generated queries, and can be used inline in custom queries.
 *
 * @param {import("../common/types").DatabasePostOrderBy} [orderBy]
 * @param {import("../common/types").DatabasePostOrderBySpec} [orderBySpec]
 * @param {{ skipValidator?: boolean, shortName?: string }} [options]
 * @returns {QueryPart<any>}
 */
export function postOrderBy(orderBy, orderBySpec, options = {}) {
  options.shortName ??= "p.";
  if (!options.shortName.endsWith(".")) {
    options.shortName += ".";
  }
  orderBy ??= ["createdAt", "updatedAt", "id"];
  orderBySpec ??= {};
  if (!options.skipValidator) {
    const validatedOrderBy = validateDatabasePostOrderByValidated(orderBy);
    if (validatedOrderBy.error) {
      throw AppError.serverError({
        message: "Invalid orderBy array",
        error: validatedOrderBy.error,
      });
    }
    orderBy = validatedOrderBy.value;
    const validatedOrderBySpec = validateDatabasePostOrderBySpec(orderBySpec);
    if (validatedOrderBySpec.error) {
      throw AppError.serverError({
        message: "Invalid orderBySpec object",
        error: validatedOrderBySpec.error,
      });
    }
    orderBySpec = validatedOrderBySpec.value;
  }
  if (isQueryPart(orderBy)) {
    return orderBy;
  }
  let str = "";
  for (const value of orderBy) {
    if (str.length !== 0) {
      str += ", ";
    }
    str += `${options.shortName}"${value}" ${orderBySpec[value] ?? "ASC"}`;
  }
  return query([str]);
}

/**
 * Count the records in the 'post' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types").DatabasePostWhere} where
 * @returns {Promise<number>}
 */
async function postCount(sql, where) {
  const [result] =
    await query`select count(p."id") as "recordCount" FROM "post" p WHERE ${postWhere(
      where,
    )}`.exec(sql);
  return Number(result?.recordCount ?? "0");
}

/**
 * Insert a record in the 'post' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types").DatabasePostInsert["insert"]} insert
 * @param {{ withPrimaryKey?: boolean }} [options={}]
 * @returns {Promise<import("../common/types").DatabasePost[]>}
 */
function postInsert(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return Promise.resolve([]);
  }
  return postInsertInternal({ insert, returning: "*" }).exec(sql);
}

/**
 * Insert a record in the 'post' table
 *
 * @param {import("../common/types").DatabasePostInsert} input
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types").DatabasePost>}
 */
function postInsertInternal(input) {
  const { error, value: validatedInput } =
    validateDatabasePostInsertValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Insert input validation failed",
      error,
    });
  }
  const qb = query`
  INSERT INTO "post"
    ("id","text","title","createdAt","updatedAt")
  VALUES
  `;
  /** @type {string[]} */
  const str = [];
  const args = [];
  for (const insert of validatedInput.insert) {
    if (str.length) {
      str.push(", (");
    } else {
      str.push("(");
    }
    if (isNil(insert.id)) {
      args.push(undefined);
      str.push("DEFAULT, ");
    } else {
      args.push(insert.id);
      str.push(", ");
    }
    args.push(insert.text ?? null);
    str.push(", ");
    args.push(insert.title ?? null);
    str.push(", ");
    if (isNil(insert.createdAt)) {
      args.push(undefined);
      str.push("DEFAULT, ");
    } else {
      args.push(insert.createdAt);
      str.push(", ");
    }
    if (isNil(insert.updatedAt)) {
      args.push(undefined);
      str.push("DEFAULT, ");
    } else {
      args.push(insert.updatedAt);
      str.push(", ");
    }
    // We have added an extra comma, so remove it.
    str[str.length - 1] = str.at(-1)?.slice(0, -2) ?? "";
    args.push(undefined);
    str.push(")");
    args.push(undefined);
  }
  if (validatedInput.returning === "*") {
    str.push(` RETURNING "id","text","title","createdAt","updatedAt"`);
    args.push(undefined);
  } else if (Array.isArray(validatedInput.returning)) {
    str.push(
      ` RETURNING ${JSON.stringify(validatedInput.returning).slice(1, -1)}`,
    );
    args.push(undefined);
  }
  qb.append(query(str, ...args));
  return wrapQueryPart(qb, validateDatabasePost, {
    hasCustomReturning: Array.isArray(validatedInput.returning),
  });
}

/**
 * Upsert a record in the 'post' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types").DatabasePostInsert["insert"]} insert
 * @returns {Promise<import("../common/types").DatabasePost[]>}
 */
function postUpsertOnId(sql, insert) {
  return postUpsertOnIdInternal({ insert, returning: "*" }).exec(sql);
}

/**
 * Upsert a record in the 'post' table based on the primary key.
 *
 * @param {import("../common/types").DatabasePostInsert} input
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types").DatabasePost>}
 */
function postUpsertOnIdInternal(input) {
  const { error, value: validatedInput } =
    validateDatabasePostInsertValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Insert input validation failed",
      error,
    });
  }
  const { queryPart } = postInsertInternal({ insert: input.insert });
  /** @type {string[]} */
  const str = [];
  const args = [];
  str.push(`ON CONFLICT ("id") DO UPDATE SET
    "text" = COALESCE(EXCLUDED."text", "post"."text"),
    "title" = COALESCE(EXCLUDED."title", "post"."title"),
    "updatedAt" = COALESCE(EXCLUDED."updatedAt", "post"."updatedAt")`);
  if (validatedInput.returning === "*") {
    str.push(` RETURNING "id","text","title","createdAt","updatedAt"`);
    args.push(undefined);
  } else if (Array.isArray(validatedInput.returning)) {
    str.push(
      ` RETURNING ${JSON.stringify(validatedInput.returning).slice(1, -1)}`,
    );
    args.push(undefined);
  }
  queryPart.append(query(str, ...args));
  return wrapQueryPart(queryPart, validateDatabasePost, {
    hasCustomReturning: Array.isArray(validatedInput.returning),
  });
}

/** @type {any} */
const postUpdateSpec = {
  schemaName: "",
  name: "post",
  shortName: "p",
  columns: ["id", "text", "title", "createdAt", "updatedAt"],
  where: postWhereSpec,
  injectUpdatedAt: true,
  fields: {
    id: {
      type: "uuid",
      atomicUpdates: [],
    },
    text: {
      type: "string",
      atomicUpdates: ["$append"],
    },
    title: {
      type: "string",
      atomicUpdates: ["$append"],
    },
    createdAt: {
      type: "date",
      atomicUpdates: ["$add", "$subtract"],
    },
    updatedAt: {
      type: "date",
      atomicUpdates: ["$add", "$subtract"],
    },
  },
};

/**
 * Insert a record in the 'post' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types").DatabasePostUpdate} update
 * @returns {Promise<import("../common/types").DatabasePost[]>}
 */
function postUpdate(sql, update) {
  if (update?.returning === "*" || !update?.returning) {
    return postUpdateInternal(update).exec(sql);
  }
  // @ts-expect-error
  return postUpdateInternal(update).execRaw(sql);
}

/**
 * Update records in the 'post' table
 *
 * @param {import("../common/types").DatabasePostUpdate} input
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types").DatabasePost>}
 */
function postUpdateInternal(input) {
  const { error, value: validatedInput } =
    validateDatabasePostUpdateValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Update input validation failed",
      error,
    });
  }
  return wrapQueryPart(
    generatedUpdateHelper(postUpdateSpec, validatedInput),
    validateDatabasePost,
    { hasCustomReturning: Array.isArray(validatedInput.returning) },
  );
}

/**
 * Insert a record in the 'post' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types").DatabasePostWhere} [where]
 * @returns {Promise<void>}
 */
function postDelete(sql, where = {}) {
  return postDeleteInternal(where).exec(sql);
}

/**
 * Remove records from the 'post' table
 *
 * @param {import("../common/types").DatabasePostWhere} [where]
 * @returns {import("@compas/store").QueryPart<any>}
 */
function postDeleteInternal(where = {}) {
  return query`DELETE FROM "post" p WHERE ${postWhere(where)}`;
}

/** @type {any} */
export const postQueryBuilderSpec = {
  name: "post",
  shortName: "p",
  orderByExperimental: postOrderBy,
  where: postWhereSpec,
  columns: ["id", "text", "title", "createdAt", "updatedAt"],
  relations: [],
};

/**
 * Query records in the 'post' table, optionally joining related tables.
 *
 * @param {import("../common/types").DatabasePostQueryBuilder} [input]
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types").QueryResultDatabasePost>}
 */
export function queryPost(input = {}) {
  const { error, value: validatedInput } =
    validateDatabasePostQueryBuilderValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Query builder input validation failed",
      error,
    });
  }
  return wrapQueryPart(
    generatedQueryBuilderHelper(postQueryBuilderSpec, validatedInput, {}),
    validateQueryResultDatabasePost,
    { hasCustomReturning: validatedInput.select?.length !== 5 },
  );
}
